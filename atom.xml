<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>djwang呀</title>
  
  <subtitle>时至今日你仍是我的光芒</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-25T15:33:20.351Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>djwang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字节教育后端实习面经集1</title>
    <link href="http://yoursite.com/2020/06/18/bytedanceinterview1/"/>
    <id>http://yoursite.com/2020/06/18/bytedanceinterview1/</id>
    <published>2020-06-18T14:31:49.000Z</published>
    <updated>2020-06-25T15:33:20.351Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>许愿字节offer </p></blockquote><a id="more"></a><h2 id="字节教育后端三轮面经，牛客-王小C"><a href="#字节教育后端三轮面经，牛客-王小C" class="headerlink" title="字节教育后端三轮面经，牛客@王小C"></a>字节教育后端三轮面经，牛客@王小C</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>1、final (类, 成员变量, 方法)</p><ul><li>修饰类，不可被继承</li><li>修饰方法，不可被重写</li><li>修饰变量时，只能被赋值一次，无法更改，但修饰引用类型变量时，只是对象地址不更改，值可以改变</li></ul><p>2、==和equals的区别</p><ul><li>“==” 比较的是对象的地址是不是相等，基本数据类型比较值的相等；</li><li>equals如果对象没有重写，等价于==，可重写判断对象内容的相等。</li><li>hashcode，本地内存地址，一般重写equals,也要重写hashcode，保证哈希集合中判断的效率和去重，hashcode相等equals相等，反之未必</li></ul><p>3、Java的多线程同步方式(Lock类, synchonized, volatile)</p><ol><li>JUC的lock类是Lock框架锁定的一个抽象，允许定义Lock的多种实现，如ReentrantLock就是实现了lock；</li><li>synchronized 是互斥锁,声明代码块时可以使其具有原子性和可见性；</li><li>而volatile只保证了可见性，不具有原子性，因此不保证线程安全。</li></ol><p>4、synchonized仔细讲一下(jvm指令, 锁优化, 和JUC的lock的区别) 和lock相比，synchonized修饰的方法和语句块在执行完自动释放锁，不需要手动获得锁释放锁；<br>5、聊GC(新生代 老年代, 回收算法, 收集器)</p><ul><li>判断内存回收<ul><li>引用计数算法，无法检测出循环引用</li><li>可达性分析</li></ul></li><li>垃圾回收算法：<ul><li>标记-清除算法</li><li>复制算法</li><li>标记-整理算法</li><li>分代回收算法</li></ul></li><li>常见的垃圾收集器<ul><li>Serial收集器、Serial Old (标记整理算法)、ParNew收集器；</li><li>Parallel Scavenge收集器(复制算法)、Parallel Old收集器(标记整理算法)；</li><li>Concurrent Mark Sweep (标记清除算法);</li><li>G1收集器(标记整理算法)</li></ul></li></ul><p>6、进程、线程区别(linux中怎么实现)</p><blockquote><p>1.进程与线程<br>进程：具有独立功能的程序关于某个数据集合上的一次运行活动。<br>线程：进程的一个实体。<br>比喻：一列火车是一个进程，火车的每一节车厢是线程。<br>2.进程与线程的联系<br>①一个线程只能属于一个进程，一个进程可以有多个线程；<br>②系统资源分配给进程，同一进程的所有线程共享该进程的所有资源；<br>③真正在处理机上运行的是线程；<br>④不同进程的线程间利用消息通信的方式实现同步。<br>3.进程与线程的区别<br>①调度：线程是系统调度和分配的基本单位，进程是作为拥有系统资源的基本单位；<br>②并发性：进程之间可以并发执行，同一进程的多个线程时间亦可以并发执行；<br>③拥有资源：进程是拥有资源的独立单位，线程不拥有资源，但可以访问隶属于进程的资源；<br>④系统开销：创建和撤销进程的开销更大；进程拥有独立的地址空间，一个进程的崩溃不会影响其他进程；线程拥有自己的堆栈和局部变量，没有独立的地址空间，因此进程里的一个线程崩溃会导致其他线程均崩溃<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/sinat_21107433/article/details/82809946" target="_blank" rel="noopener">https://blog.csdn.net/sinat_21107433/article/details/82809946</a></p></blockquote><p>7、僵尸进程的产生 如何避免</p><ul><li>如果子进程先于父进程退出， 同时父进程又没有调用wait/waitpid，则该子进程将成为僵尸进程。通过ps命令，我们可以看到该进程的状态为Z(表示僵死);</li><li>避免：<ul><li>使用signal函数显式忽略SIGCHLD信号；</li><li>调用wait()或者waitpid();</li><li>fork两次，父进程fork子进程后继续执行，子进程fork一个孙进程后退出，此时孙进程会被init进程接管，避免僵尸进程，当然子进程的退出还是要处理的。</li></ul></li></ul><p>8、三次握手四次挥手(time_wait)<br>    略；在客户端发送针对服务器FIN的ACK后，进入time_wait状态，经过2MSL（Maximun Segment Lifetime）后，没有收到服务器传来的报文，则确定服务器收到ACK指令，TCP连接正式释放。</p><p>9、算法题: 买卖股票 leetcode题</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>进程间通信方式(和上面重复了)</p><blockquote><p>①管道：半双工的通信方式，数据只能单向流动，且只能在有亲缘关系（父子进程或兄弟进程）的进程间使用；<br>②命名管道：FIFO，半双工的通信方式，但允许在无亲缘关系的进程间通信；<br>③消息队列：消息的链表，存放在内核中，并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点；<br>④信号量：是一个计数器，用于控制多个进程间对共享资源的访问；<br>⑤共享内存：映射一段能被其他进程访问的内存，这段内存由一个进程创建，但多个进程都可以访问；<br>⑥套接字<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/sinat_21107433/article/details/82809946" target="_blank" rel="noopener">https://blog.csdn.net/sinat_21107433/article/details/82809946</a></p></blockquote><p>浏览器输入一个url后发生什么</p><p>算法题: 打家劫舍 原题</p><p>算法题: 给定升序整形数组和m，a和b是数组中的两个元素；求a+b=m的数据对有多少？(双指针)</p><p>其他: 字节的前两面是连在一起中间休息15分钟</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>jdk8默认的垃圾回收器, 知道哪些垃圾回收器? G1详细说一下</p><p>synchronized关键字的底层是什么?</p><ul><li>无状态锁、偏向锁、轻量锁、重量锁</li></ul><p>线程之间哪些资源是共享的? 什么是独享的?</p><ul><li>共享：堆；全局变量；静态变量；文件等公共资源；</li><li>独享：栈；寄存器；</li></ul><p>堆和栈有什么区别?</p><p>linux查看资源的命令?怎么样查看哪些端口被占用了</p><p>linux内存中swap是什么? 什么用?</p><p>用户态和内核态的区别? 为什么要有用户态内核态区别?</p><p>中断有哪些类型, 区别?</p><p>死锁概念? 条件?</p><p>算法题: 奇数位递增偶数位递减的数组,排序</p><p>get,post区别?</p><p>get可以缓存? 在INTP(?没听懂在哪)里是怎么实现的?</p><p>写sql, group by的查询?</p><p>mySQL的搜索引擎? innodb和myISAM的区别</p><h2 id="字节教育业务后台开发面经-牛客-BinFromFD"><a href="#字节教育业务后台开发面经-牛客-BinFromFD" class="headerlink" title="字节教育业务后台开发面经 牛客@BinFromFD"></a>字节教育业务后台开发面经 牛客@BinFromFD</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><p>0、自我介绍+项目介绍<br>1、Https的过程（详细地说了对称加密和非对称加密，CA，还有随机数生成秘钥的方式）；http和tcp的关系；输入URL之后的过程</p><p>2、数据库如何实现并发；可重复读是什么；有一段代码，两个session，判断结果是什么（和重复读有关）；数据库用什么实现可重复读。<br>3、面向对象的三大特性；多态性是什么，举例；运行时多态、编译时多态</p><ul><li>封装、继承、多态<ul><li>编译时多态<br>主要是方法的重载，通过参数列表的不同来区分不同的方法。</li><li>运行时多态<br>也叫作动态绑定，一般是指在执行期间（非编译期间）判断引用对象的实际类型，根据实际类型判断并调用相应的属性和方法。主要用于继承父类和实现接口时，父类引用指向子类对象。</li></ul></li></ul><p>4、知道什么设计模式？写一个线程安全的单例模式。</p><pre><code>- 单例、策略、工厂、代理- 加锁懒汉式、饿汉式</code></pre><p>5、线程和进程<br>    进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同<br>    进程是资源分配的最小单位，线程是CPU调度的最小单位</p><p>6、打印斐波那契数列<br>    略</p><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><p>0、介绍项目<br>1、Java的Map和Set和List的区别<br>2、Map有哪些类型，HashMap底层结构，如何实现线程安全。ConcurrentHashMap在一个读一个写的时候会不会加锁呢？HashTable<br>3、数据库为什么用B+树。联合索引特点<br>4、Spring知道吗<br>    AOP、IOC<br>5、判断二叉搜索树。O(1)空间<br>6、一致性Hash算法</p><h3 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h3><p>0、自我介绍<br>1、如何在一堆数中找到想要的数，说几种方法。（我问是排好序的呢还是没排好序的。他说都讲讲。排好序的二分，没排好的直接搜索。他又问还有吗？我说，复杂度已经只有O(n)了；他说可能有一百万个数。所以用多线程）<br>2、项目中最大的挑战<br>3、一个数据库的查询问题。<br>4、写快排</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;许愿字节offer &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="面经" scheme="http://yoursite.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="字节跳动" scheme="http://yoursite.com/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
      <category term="bytedance" scheme="http://yoursite.com/tags/bytedance/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数据库知识点整理</title>
    <link href="http://yoursite.com/2020/06/18/db/"/>
    <id>http://yoursite.com/2020/06/18/db/</id>
    <published>2020-06-18T11:09:48.000Z</published>
    <updated>2020-06-25T15:28:03.350Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据库知识点整理 </p></blockquote><a id="more"></a><h3 id="0、MySQL-sql语句执行过程"><a href="#0、MySQL-sql语句执行过程" class="headerlink" title="0、MySQL sql语句执行过程"></a>0、MySQL sql语句执行过程</h3><p><img src="/images/202006/mysqlexecute.png" alt="sql执行过程"></p><h3 id="1、MYISAM与innodb搜索引擎原理"><a href="#1、MYISAM与innodb搜索引擎原理" class="headerlink" title="1、MYISAM与innodb搜索引擎原理"></a>1、MYISAM与innodb搜索引擎原理</h3><ul><li>MyISAM引擎（Mysql5.1前默认引擎）使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。其采用表定义文件、索引文件与数据文件，索引文件只存放索引，叶子节点存放数据的物理地址。数据文件存放数据,可移植性较好。其索引方式是非聚集的。</li><li>InnoDB也使用B+Tree作为索引结构。但是它的主索引与数据都放在一个文件中。这种索引叫做聚集索引，因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</li><li>区别一：Innodb支持事务、外键等高级数据库功能，而myisam强调性能，查询有原子性，不提供事务支持；</li><li>区别二：innodb支持事务和行级锁，而myisam只支持表级锁；</li><li>区别三：InnoDB的主索引与数据都放在一个文件中。而MYISAM是分开存放的；</li><li>区别四：InnoDB的辅助索引data域存储相应记录主键的值而不是地址；</li><li>区别五：InnoDB的主键索引是聚集索引，而MYISAM不是聚集索引。</li></ul><h3 id="2、最左前缀原理"><a href="#2、最左前缀原理" class="headerlink" title="2、最左前缀原理"></a>2、最左前缀原理</h3><p>MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组&lt;a1, a2, …, an&gt;，在联合索引中，比如Student表存在姓名学号的联合索引（sno,name），最左前缀原理指的是查询条件进行精确匹配并包含索引的的第一列，才可以命中索引。<br>注：索引优化，当查询时，索引列不能是表达式的一部分或者函数参数，否则无法使用索引，如 SELECT sno FROM student WHERE sno + 1 = 5;</p><h3 id="3、事务ACID"><a href="#3、事务ACID" class="headerlink" title="3、事务ACID"></a>3、事务ACID</h3><ul><li>原子性，事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要不全部失败回滚；</li><li>一致性，数据库在事务执行前后都保持一致性状态；</li><li>隔离性，一个事务所做的修改在最终提交以前，对其它事务是不可见的；</li><li>持久性，一旦事务提交，则其所做的修改将会永远保存到数据库中；<br><a href="/images/202006/acid.png">ACID</a></li></ul><h3 id="4、隔离级别"><a href="#4、隔离级别" class="headerlink" title="4、隔离级别"></a>4、隔离级别</h3><ul><li>read uncommit:读不加锁，写加共享锁。会产生脏读、幻读。</li><li>read commit：读加共享锁，写加排它锁，但不加间隙锁。间隙锁的主要作用是防止不可重复读，但会加大锁的范围。</li><li>repeatable read(innodb默认):读加共享锁，写加间隙排它锁。注意，Innodb对这个级别进行了特殊处理，使得这个级别能够避免幻读，但不是所有引擎都能够防止幻读！</li><li>serialization：会给整张表加锁，强一致，但是效率低。<h3 id="5、"><a href="#5、" class="headerlink" title="5、"></a>5、</h3><h3 id="20、galera"><a href="#20、galera" class="headerlink" title="20、galera"></a>20、galera</h3></li><li>多主架构：真正的多点读写的集群，在任何时候读写数据，都是最新的。</li><li>同步复制，各节点间无延迟且节点宕机不会导致数据丢失。</li><li>紧密耦合，所有节点均保持相同状态，节点间无不同数据。</li><li>无需主从切换操作。</li><li>无需进行读写分离。</li><li>并发复制：从节点在APPLY数据时，支持并行执行，有更好的性能表现。</li><li>故障切换：在出现数据库故障时，因为支持多点写入，切的非常容易。</li><li>热插拔：在服务期间，如果数据库挂了，只要监控程序发现的够快，不可服务时间就会非常少。在节点故障期间，节点本身对集群的影响非常小。</li><li>自动节点克隆：在新增节点，或者停机维护时，增量数据或者基础数据不需要人工手动备份提供，Galera Cluster会自动拉取在线节点数据，最终集群会变为一致。</li><li>对应用透明：集群的维护，对应用程序是透明的，几乎感觉不到。</li><li>以下是缺点<ul><li>目前的复制仅仅支持InnoDB存储引擎</li><li>DELETE操作不支持没有主键的表</li><li>在多主环境下LOCK/UNLOCK TABLES不支持以及锁函数GET_LOCK(), RELEASE_LOCK()</li><li>由于集群是乐观的并发控制，事务commit可能在该阶段中止。</li><li>整个集群的写入吞吐量是由最弱的节点限制，如果有一个节点变得缓慢，那么整个集群将是缓慢的。为了稳定的高性能要求，所有的节点应使用统一的硬件</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据库知识点整理 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
    
      <category term="数据库、MySQL、DB" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81MySQL%E3%80%81DB/"/>
    
  </entry>
  
  <entry>
    <title>生产者消费者问题</title>
    <link href="http://yoursite.com/2020/06/13/producer-consumer/"/>
    <id>http://yoursite.com/2020/06/13/producer-consumer/</id>
    <published>2020-06-13T09:22:53.000Z</published>
    <updated>2020-06-13T09:32:09.858Z</updated>
    
    <content type="html"><![CDATA[<p>生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据<br><a id="more"></a></p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行down和up操作，也就是常见的P和V操作。</p><ul><li>down : 如果信号量大于0，执行-1操作；如果信号量等于0，进程睡眠，等待信号量大于0；</li><li>up ：对信号量执行+1操作，唤醒睡眠的进程让其完成down操作。<br>down和up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</li></ul><p>如果信号量的取值只能为0或者1，那么就成为了<strong>互斥量（Mutex）</strong>，0表示临界区已经加锁，1 表示临界区解锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef int semaphore;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">void P1() &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    // 临界区</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void P2() &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    // 临界区</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></p><h3 id="使用信号量实现生产者-消费者问题"><a href="#使用信号量实现生产者-消费者问题" class="headerlink" title="使用信号量实现生产者-消费者问题"></a>使用信号量实现生产者-消费者问题</h3><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。<br>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。<br>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty =0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行up(empty)操作，empty 永远都为0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#define N 100</span><br><span class="line">typedef int semaphore;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = 0;</span><br><span class="line"> </span><br><span class="line">void producer() &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        int item = produce_item();</span><br><span class="line">        down(&amp;empty);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void consumer() &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        down(&amp;full);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        int item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></p><h3 id="Java多线程实现生产者消费者模式"><a href="#Java多线程实现生产者消费者模式" class="headerlink" title="Java多线程实现生产者消费者模式"></a>Java多线程实现生产者消费者模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynContainer container=<span class="keyword">new</span> SynContainer();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(container)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(container)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SynContainer container;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生产</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"生产第"</span>+(i+<span class="number">1</span>)+<span class="string">"个面包"</span>);</span><br><span class="line">            container.push(<span class="keyword">new</span> Bread(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SynContainer container;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//消费</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"买了"</span>+(container.get().getId()+<span class="number">1</span>)+<span class="string">"个面包"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynContainer</span></span>&#123;</span><br><span class="line">    Bread[] breads=<span class="keyword">new</span> Bread[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//存储 生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Bread bread)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//缓冲区(库存)满了停止消费</span></span><br><span class="line">        <span class="keyword">if</span> (count==breads.length) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();  <span class="comment">//线程阻塞 停止生产，消费者通知生产解除阻塞</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//容器未满可以生产</span></span><br><span class="line">        breads[count]=bread;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//this.notify();</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();  <span class="comment">//生产了商品可以通知生产者恢复消费了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取 消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Bread <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//缓冲区为空（没有面包）就需要停止消费</span></span><br><span class="line">        <span class="keyword">if</span> (count==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();  <span class="comment">//线程阻塞 停止消费，生产者通知消费解除阻塞</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有数据只能等待</span></span><br><span class="line">        count--;</span><br><span class="line">        <span class="comment">//this.notify();</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();  <span class="comment">//消费了商品可以通知生产者恢复生产了</span></span><br><span class="line">        <span class="keyword">return</span> breads[count];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//面包</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bread</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据&lt;br&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>疫情期间，既要每日测温，也要做LeetCode739、每日温度</title>
    <link href="http://yoursite.com/2020/06/13/leetcode739/"/>
    <id>http://yoursite.com/2020/06/13/leetcode739/</id>
    <published>2020-06-13T09:20:25.000Z</published>
    <updated>2020-06-13T09:24:19.333Z</updated>
    
    <content type="html"><![CDATA[<p>根据每日气温列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。<br><a id="more"></a><br>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。<br><strong>提示</strong>：气温列表长度的范围是[1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><p><strong>分析</strong>：<br>方法一：使用单调栈记录温度天数，遍历时，当遇到比栈顶高的温度时，出栈并记录栈顶的时间和当前温度时间之间的等待天数。出栈后再次查看栈顶时间的温度是否小于当前温度，小于则继续出栈，大于则不做处理，继续入栈。<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line"><span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">Deque&lt;Integer&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">stack.offerLast(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;T.length;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; T[stack.peekLast()]&lt;T[i])&#123;</span><br><span class="line">res[stack.peekLast()]=i-stack.peekLast();</span><br><span class="line">stack.pollLast();</span><br><span class="line">&#125;</span><br><span class="line">stack.offerLast(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">res[stack.pollLast()]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法二：从最后一天向前递推，显然最后天为0，倒数第二天时，如果最后一天大于这天，则为1，小于则为0。可以得到规律根据T[i+1]天的结果即可得到T[i]的结果</p><ul><li>如果T[i]&lt;T[i+1]时，res[i]=1；</li><li>如果T[i]&gt;T[i+1]时，res[i+1]=0,那么res[i]=0,若res[i+1]&gt;0,那么继续比较T[i]和T[i+1+res[i+1]],和比T[i+1]大的那天比较。<br>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line"><span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">res[T.length - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = T.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; T.length; j += res[j]) &#123;</span><br><span class="line"><span class="keyword">if</span> (T[i] &lt; T[j]) &#123;</span><br><span class="line">res[i] = j - i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (res[j] == <span class="number">0</span>) &#123;</span><br><span class="line">res[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据每日气温列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="OJ" scheme="http://yoursite.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>leetcode42、接雨水</title>
    <link href="http://yoursite.com/2020/06/13/leetcode42/"/>
    <id>http://yoursite.com/2020/06/13/leetcode42/</id>
    <published>2020-06-13T02:51:39.000Z</published>
    <updated>2020-06-13T03:50:07.092Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><img src="/images/202006/rainwatertrap.png" alt="rainwatertrap"><br><a id="more"></a><br>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</p><blockquote><p>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p></blockquote><p><strong>分析</strong>：<br>方法一：以一个指针记录当前的高度，另一个指针遍历其他柱子，当遇到超过当前柱子的高度的柱子时，就可以满足接到雨水，此时计算该凹处的雨水量，并更新当前柱子继续遍历。在数组的另一边可能会遇到逐渐减少的情况会一直得不到处理，此时对剩余柱子逆序做刚才的处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(height.length&lt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (height[pre] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">pre++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pre+<span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (height[i] &gt;= height[pre]) &#123;</span><br><span class="line"><span class="keyword">int</span> min = height[pre];</span><br><span class="line"><span class="keyword">for</span> (; pre &lt; i; pre++) &#123;</span><br><span class="line"><span class="keyword">if</span> (min &gt; height[pre])</span><br><span class="line">res += min - height[pre];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pre &lt; height.length - <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> p = height.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (height[p] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">p--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = p-<span class="number">1</span>; i &gt;= pre; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (height[i] &gt;= height[p]) &#123;</span><br><span class="line"><span class="keyword">int</span> min = height[p];</span><br><span class="line"><span class="keyword">for</span> (; p &gt; i; p--) &#123;</span><br><span class="line"><span class="keyword">if</span> (min &gt; height[p])</span><br><span class="line">res += min - height[p];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法二：用两个数组分别记录每个柱子的左右最大值，最终累计其凹处的雨水。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = height.length;</span><br><span class="line"><span class="comment">// left[i]表示i左边的最大值，right[i]表示i右边的最大值</span></span><br><span class="line"><span class="keyword">int</span>[] left=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"><span class="keyword">int</span>[] right=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">left[i] = Math.max(left[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">right[i] = Math.max(right[i + <span class="number">1</span>], height[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> level = Math.min(left[i], right[i]);</span><br><span class="line">res += Math.max(<span class="number">0</span>, level - height[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;br&gt;&lt;img src=&quot;/images/202006/rainwatertrap.png&quot; alt=&quot;rainwatertrap&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="单调栈" scheme="http://yoursite.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>量子噬猪！leetcode458、可怜的小猪</title>
    <link href="http://yoursite.com/2020/06/10/leetcode458/"/>
    <id>http://yoursite.com/2020/06/10/leetcode458/</id>
    <published>2020-06-10T14:44:15.000Z</published>
    <updated>2020-06-10T14:55:29.731Z</updated>
    
    <content type="html"><![CDATA[<p>有 1000 只水桶，其中有且只有一桶装的含有毒药，其余装的都是水。它们从外观看起来都一样。如果小猪喝了毒药，它会在 15 分钟内死去。</p><p>问题来了，如果需要你在一小时内，弄清楚哪只水桶含有毒药，你最少需要多少只猪？<br><a id="more"></a><br>回答这个问题，并为下列的进阶问题编写一个通用算法。<br><strong>进阶</strong>：<br>假设有 n 只水桶，猪饮水中毒后会在 m 分钟内死亡，你需要多少猪（x）就能在 p 分钟内找出 “有毒” 水桶？这 n 只水桶里有且仅有一只有毒的桶。</p><p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poorPigs</span><span class="params">(<span class="keyword">int</span> buckets, <span class="keyword">int</span> minutesToDie, <span class="keyword">int</span> minutesToTest)</span> </span>&#123;</span><br><span class="line"><span class="comment">//一个小时，15分钟会死去，可以有五次机会</span></span><br><span class="line"><span class="comment">//将1000桶水以五进制表示，0-4对应每个15分钟喝水，前四次猪还活着表示第五次有毒，因此可以有五个状态</span></span><br><span class="line"><span class="comment">//那么5^5&gt;1000，即5只猪可根据猪的死去状态试出毒水桶</span></span><br><span class="line"><span class="keyword">int</span> time=minutesToTest/minutesToDie+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pig=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// while(true)&#123;</span></span><br><span class="line"><span class="comment">//     if(Math.pow(time,pig)&gt;=buckets) return pig;</span></span><br><span class="line"><span class="comment">//     pig++;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//这部分可以用对数</span></span><br><span class="line">pig = (<span class="keyword">int</span>) Math.ceil(Math.log(buckets)/Math.log(time));</span><br><span class="line"><span class="keyword">return</span> pig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有 1000 只水桶，其中有且只有一桶装的含有毒药，其余装的都是水。它们从外观看起来都一样。如果小猪喝了毒药，它会在 15 分钟内死去。&lt;/p&gt;
&lt;p&gt;问题来了，如果需要你在一小时内，弄清楚哪只水桶含有毒药，你最少需要多少只猪？&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="http://yoursite.com/2020/06/07/SpringBoot/"/>
    <id>http://yoursite.com/2020/06/07/SpringBoot/</id>
    <published>2020-06-07T02:43:24.000Z</published>
    <updated>2020-06-07T02:43:24.469Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringMVC基础知识</title>
    <link href="http://yoursite.com/2020/06/07/SpringMVC/"/>
    <id>http://yoursite.com/2020/06/07/SpringMVC/</id>
    <published>2020-06-07T02:43:16.000Z</published>
    <updated>2020-06-15T08:22:43.459Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="http://yoursite.com/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础知识</title>
    <link href="http://yoursite.com/2020/06/06/computernetwork/"/>
    <id>http://yoursite.com/2020/06/06/computernetwork/</id>
    <published>2020-06-06T13:32:31.000Z</published>
    <updated>2020-06-18T15:04:36.956Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、OSI七层网络模型及协议"><a href="#1、OSI七层网络模型及协议" class="headerlink" title="1、OSI七层网络模型及协议"></a>1、OSI七层网络模型及协议</h3><p>OSI七层模型为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层，从网络功能的角度观察：下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上3层（会话层、表示层和应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。简言之，下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。<br><a id="more"></a></p><h3 id="2、TCP-IP模型与协议"><a href="#2、TCP-IP模型与协议" class="headerlink" title="2、TCP/IP模型与协议"></a>2、TCP/IP模型与协议</h3><p>分为网络接口层、网络层、传输层、应用层。</p><ul><li>应用层,单位是数据段，协议包括FTP(文件传输协议)、HTTP(超文本传输协议)、Telent(远程终端协议)、SMTP(简单邮件传送协议)、DNS等。</li><li>传输层单位是数据包，提供两种端到端的通信服务。其中TCP协议(Transmission Control Protocol)提供可靠的数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。</li><li>网络层单位是数据帧，有IP和ARP等协议，地址解析协议(Address Resolution Protocol,ARP)提供TCP/IP协议的数据结构和实际物理硬件之间的接口。</li><li>网络接口层：单位是比特。</li></ul><h3 id="3、TCP连接三次握手"><a href="#3、TCP连接三次握手" class="headerlink" title="3、TCP连接三次握手"></a>3、TCP连接三次握手</h3><p>作用:1、信息对等，接收机器可以确认自己的发报能力和对方接收能力正常；2、防止请求超时导致脏连接，由于TTL网络报文生存时间超过TCP请求超时时间，故可能发送超时请求导致脏连接。</p><h3 id="4、TCP断开连接四次挥手"><a href="#4、TCP断开连接四次挥手" class="headerlink" title="4、TCP断开连接四次挥手"></a>4、TCP断开连接四次挥手</h3><p>作用:释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。<br><a href="https://blog.csdn.net/guyuealian/article/details/52535294" target="_blank" rel="noopener">三次握手四次挥手</a></p><h3 id="5、TCP拆包和粘包"><a href="#5、TCP拆包和粘包" class="headerlink" title="5、TCP拆包和粘包"></a>5、TCP拆包和粘包</h3><ul><li>由于一批发送的数据太多或缓冲区太小，将一批数据分成多个segment来发送，叫拆包。</li><li>将多批小数据写入一个缓冲区，或读取不及时，一个缓冲区存在多批数据，叫粘包。</li><li>解决方式：根据消息头中的长度与偏移量来重组数据。设置定长消息，使得一个缓冲区中的segment总是一批数据的。设置消息边界。</li></ul><h3 id="6、网络IO实现方式：BIO、NIO、AIO"><a href="#6、网络IO实现方式：BIO、NIO、AIO" class="headerlink" title="6、网络IO实现方式：BIO、NIO、AIO"></a>6、网络IO实现方式：BIO、NIO、AIO</h3><ul><li>BIO：同步阻塞IO，每个请求都要一个线程来处理。</li><li>NIO：同步非阻塞IO，一个线程可以处理多个请求，适用于短连接、小数据。</li><li>AIO：异步非阻塞IO，一个线程处理多个请求，使用回调函数实现，适用于长连接、大数据</li></ul><h3 id="7、DDOS攻击原理与防御方式"><a href="#7、DDOS攻击原理与防御方式" class="headerlink" title="7、DDOS攻击原理与防御方式"></a>7、DDOS攻击原理与防御方式</h3><ul><li>SYN flood:伪造ip地址发送请求，占满半连接队列，导致正常链接被服务器抛弃。攻击方需要很高的带宽资源。</li><li>ACK flood：大量ACK连接请求服务器，服务器需要花费CPU资源去查询连接队列并回应。只有当流量很高时才会对服务器造成影响。</li><li>Connection Flood：利用真实IP，在服务器上建立大量连接，从而占满服务器连接队列，导致正常连接被丢弃。</li><li>HTTP Get Flood：发送大量会产生sql查询的连接，使得数据库负载很高。</li></ul><h3 id="8、CSRF跨站请求伪造原理"><a href="#8、CSRF跨站请求伪造原理" class="headerlink" title="8、CSRF跨站请求伪造原理"></a>8、CSRF跨站请求伪造原理</h3><ul><li>攻击者盗用了你的身份，以你的名义发送恶意请求。</li><li>例子：假如你去银行网站上通过请求 <a href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000" target="_blank" rel="noopener">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</a> 来消费1000元。然后登陆某个恶意网站，上面有同样一段代码　。由于你没有登出银行网站，因此会再消费1000.</li><li>CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！</li><li>防御方式：1.验证码；2. 后台生成token，让前端请求携带。3.使用对称加密，后端随机给前端一个密钥，前端进行加密，后端解密</li></ul><h3 id="9、会话劫持"><a href="#9、会话劫持" class="headerlink" title="9、会话劫持"></a>9、会话劫持</h3><ul><li>通过暴力破解、 预测、窃取（通过XSS攻击）等方式获取到用户session</li><li>防御方式<ul><li>更改Session名称</li><li>关闭透明化Session ID。透明化Session ID指当浏览器中的Http请求没有使用Cookie来存放Session ID时，Session ID则使用URL来传递。</li><li>设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、OSI七层网络模型及协议&quot;&gt;&lt;a href=&quot;#1、OSI七层网络模型及协议&quot; class=&quot;headerlink&quot; title=&quot;1、OSI七层网络模型及协议&quot;&gt;&lt;/a&gt;1、OSI七层网络模型及协议&lt;/h3&gt;&lt;p&gt;OSI七层模型为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层，从网络功能的角度观察：下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上3层（会话层、表示层和应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。简言之，下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>vivo2020校招A卷第一题、服务部署</title>
    <link href="http://yoursite.com/2020/06/06/vivo2020A/"/>
    <id>http://yoursite.com/2020/06/06/vivo2020A/</id>
    <published>2020-06-06T13:02:11.000Z</published>
    <updated>2020-06-06T13:22:56.446Z</updated>
    
    <content type="html"><![CDATA[<p>小v是公司的运维工程师，现有一个有关应用程序部署的任务如下：</p><blockquote><p>1、一台服务器的磁盘空间、内存是固定的，现在有N个应用程序要部署；<br>2、每个应用程序所需要的磁盘、内存不同，每个应用程序允许访问的用户数也不同，且同一个应用程序不能在一台服务器上部署多个。</p></blockquote><p>对于一台服务器而言，如何组合部署应用程序能够使得单台服务器允许访问的用户数最多？<br><a id="more"></a><br><strong>输入描述</strong>：</p><blockquote><p>输入包括三个参数，空格分隔，分别表示服务器的磁盘大小、内存大小，以及应用程序列表；<br>其中第三个参数即应用程序列表，表述方式为：多个应用程序信息之间用 ‘#’ 分隔，每个应用程序的信息包括 ‘,’ 分隔的部署所需磁盘空间、内存、允许访问的用户量三个数字；比如 50,20,2000 表示部署该应用程序需要50G磁盘空间，20G内存，允许访问的用户数是2000</p></blockquote><p><strong>输出描述</strong>：</p><blockquote><p>单台服务器能承载的最大用户数</p></blockquote><p>示例：</p><blockquote><p>输入：<br>15 10 5,1,1000#2,3,3000#5,2,15000#10,4,16000<br>输出：<br>31000</p></blockquote><p>分析：三维背包问题，动态规划求得优解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> totalDisk, <span class="keyword">int</span> totalMemory, List&lt;Service&gt; services)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = services.size();</span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>][totalDisk + <span class="number">1</span>][totalMemory + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = totalDisk; j &gt; <span class="number">0</span>; j--)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = totalMemory; k &gt; <span class="number">0</span>; k--)&#123;</span><br><span class="line"><span class="keyword">if</span>(j &gt;= services.get(i - <span class="number">1</span>).getDisk() &amp;&amp; k &gt;= services.get(i - <span class="number">1</span>).getMemory())&#123;</span><br><span class="line">dp[i][j][k] = Math.max(dp[i - <span class="number">1</span>][j][k], dp[i - <span class="number">1</span>][j - services.get(i - <span class="number">1</span>).getDisk()][k - services.get(i - <span class="number">1</span>).getMemory()] + services.get(i - <span class="number">1</span>).getusers());</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j][k] = dp[i - <span class="number">1</span>][j][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[len][totalDisk][totalMemory];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Service类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> disk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> memory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> users;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Service</span><span class="params">(<span class="keyword">int</span> disk, <span class="keyword">int</span> memory, <span class="keyword">int</span> users)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.disk = disk;</span><br><span class="line"><span class="keyword">this</span>.memory = memory;</span><br><span class="line"><span class="keyword">this</span>.users = users;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> disk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisk</span><span class="params">(<span class="keyword">int</span> disk)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.disk = disk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> memory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(<span class="keyword">int</span> memory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.memory = memory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getusers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setusers</span><span class="params">(<span class="keyword">int</span> users)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.users = users;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小v是公司的运维工程师，现有一个有关应用程序部署的任务如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、一台服务器的磁盘空间、内存是固定的，现在有N个应用程序要部署；&lt;br&gt;2、每个应用程序所需要的磁盘、内存不同，每个应用程序允许访问的用户数也不同，且同一个应用程序不能在一台服务器上部署多个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于一台服务器而言，如何组合部署应用程序能够使得单台服务器允许访问的用户数最多？&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="背包问题" scheme="http://yoursite.com/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode128、最长连续序列</title>
    <link href="http://yoursite.com/2020/06/06/leetcode128/"/>
    <id>http://yoursite.com/2020/06/06/leetcode128/</id>
    <published>2020-06-06T05:15:24.000Z</published>
    <updated>2020-06-06T05:43:51.596Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个未排序的整数数组，找出最长连续序列的长度。<br>要求算法的时间复杂度为 O(n)。<br><a id="more"></a><br><strong>示例</strong>：</p><blockquote><p>输入：[100, 4, 200, 1, 3, 2]<br>输出: 4<br>解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</p></blockquote><p>分析：使用哈希先遍历存一遍，再次遍历将连续存在的序列取出。时间为O(2*n).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">map.put(num,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">cur=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> left=num-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right=num+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(map.remove(left--)!= <span class="keyword">null</span>)&#123;</span><br><span class="line">cur++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(map.remove(right++)!= <span class="keyword">null</span>)&#123;</span><br><span class="line">cur++;</span><br><span class="line">&#125;</span><br><span class="line">res= Math.max(res,cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看评论里，也可以在第一次时，设置value值为当前序列的长度，但没这好理解。另Map,似乎用Set更好，List也可以，= =！<br>注:这题有点并查集的概念，估计也是难度为困难的原因，并查集为处理将多个元素的集合问题，将有联系的的单元素合并为大的集合，以达到快速查询的效果</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个未排序的整数数组，找出最长连续序列的长度。&lt;br&gt;要求算法的时间复杂度为 O(n)。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>震惊，该物质不溶于自身！LeetCode238、除自身以外数组的乘积</title>
    <link href="http://yoursite.com/2020/06/04/leetcode238/"/>
    <id>http://yoursite.com/2020/06/04/leetcode238/</id>
    <published>2020-06-04T04:32:44.000Z</published>
    <updated>2020-06-04T04:37:54.856Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。<br><a id="more"></a><br><strong>示例</strong>：</p><blockquote><p>输入：[1,2,3,4]<br>输出：[24,12,8,6]</p></blockquote><p><strong>分析</strong>：用两个数组分别储存除自身以外的左右之积，最后相乘返回<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"><span class="comment">//左右累乘</span></span><br><span class="line"><span class="keyword">int</span> len=nums.length;</span><br><span class="line"><span class="keyword">int</span>[] left=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"><span class="comment">//int[] right=new int[len];</span></span><br><span class="line"><span class="keyword">int</span> right=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">left[i]=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//right[i]=1;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">left[i]=left[i-<span class="number">1</span>] * nums[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="comment">//对right数组优化下</span></span><br><span class="line"><span class="comment">//right[i]=right[i+1] * nums[i+1];</span></span><br><span class="line">right=right * nums[i+<span class="number">1</span>];</span><br><span class="line">left[i]=left[i]*right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个长度为 n 的整数数组 nums，其中 n &amp;gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>为什么他能靠21点成为亿万富翁？LeetCode837、新21点</title>
    <link href="http://yoursite.com/2020/06/03/leetcode837/"/>
    <id>http://yoursite.com/2020/06/03/leetcode837/</id>
    <published>2020-06-03T08:58:08.000Z</published>
    <updated>2020-06-03T09:56:49.424Z</updated>
    
    <content type="html"><![CDATA[<p>爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：<br>爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。<br>问：当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？<br><a id="more"></a><br><strong>示例1</strong>：</p><blockquote><p>输入：N = 10, K = 1, W = 10<br>输出：1.00000<br>说明：爱丽丝得到一张卡，然后停止。</p></blockquote><p><strong>示例2</strong>：</p><blockquote><p>输入：N = 6, K = 1, W = 10<br>输出：0.60000<br>说明：爱丽丝得到一张卡，然后停止。<br>在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。</p></blockquote><p><strong>分析</strong>：<br>总之，就是边缘试探，求将超未超的概率。<br>用动态规划，由已知条件得到未知的情况。<br>令dp[x]表示得分x的情况下，开始游戏并获胜的概率，这样d[0]就是结果所得。已知可以得到，当K&lt;=x&lt;=min(N,K+W-1)时已成胜局，故dp[x]=1,(K+W不能被满足)，而x&gt;=min(N,K+W+1)时dp[x]=0;<br>当0&lt;=x&lt;K时，可以知道 W*dp[x]=dp[x+1]+dp[x+2]+…+dp[x+W],即dp[x]的获胜概率，可由下一个状态的概率和得到。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span>[] dp = <span class="keyword">new</span> <span class="keyword">double</span>[K + W];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = K; i &lt;= N &amp;&amp; i &lt; K + W; i++) &#123;</span><br><span class="line">dp[i] = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = K - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= W; j++) &#123;</span><br><span class="line">dp[i] += dp[i + j] / W;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上解法复杂度为O(N+KW]，超时了。可以优化0-K间x的取值方式，以邻项计算，dp[x]-dp[x+1]=(dp[x+1]-dp[x+W+1])/W，其中0&lt;=x&lt;K-1，x=K-1时不满足，dp[K-1]可由前面的方法得到dp[K]开始值为1，dp[K-1]=(min(N,K+W-1)-K+1)/W。这样时间复杂度为O(min(N,K+W))。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span>[] dp = <span class="keyword">new</span> <span class="keyword">double</span>[K + W];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = K; i &lt;= N &amp;&amp; i &lt; K + W; i++) &#123;</span><br><span class="line">dp[i] = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">dp[K - <span class="number">1</span>] = <span class="number">1.0</span> * Math.min(N - K + <span class="number">1</span>, W) / W;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = K - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">dp[i] = dp[i + <span class="number">1</span>] + (dp[i + <span class="number">1</span>] - dp[i + W + <span class="number">1</span>]) / W;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续分析开始的解时，可以知道是以定长的窗口，来得到0&lt;=x&lt;K时dp的值，那么也可以以一个sum来计算dp[x+1]+dp[x+2]+…+dp[x+W]，每次左移时，加上dp[x]，而减去dp[X+W]，这样以 dp[x]=sum/W 的公式，也可以有上面优化解法的时间复杂度。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span>[] dp = <span class="keyword">new</span> <span class="keyword">double</span>[K + W];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = K; i &lt;= N &amp;&amp; i &lt; K + W; i++) &#123;</span><br><span class="line">dp[i] = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> sum=Math.min(N,K+W-<span class="number">1</span>)-K+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = K - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">dp[i] = sum / W;</span><br><span class="line">sum = sum-dp[i+W]+dp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：&lt;br&gt;爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。&lt;br&gt;问：当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>java比较传统方式和数据库连接池方式的性能差异</title>
    <link href="http://yoursite.com/2020/06/03/dbConnectionpoolvs/"/>
    <id>http://yoursite.com/2020/06/03/dbConnectionpoolvs/</id>
    <published>2020-06-03T06:33:10.000Z</published>
    <updated>2020-06-03T06:50:11.071Z</updated>
    
    <content type="html"><![CDATA[<p>向数据库中插入100条数据，比较传统方式和数据库连接池方式的性能差异<br><a id="more"></a></p><p>注：只是一个简单比较实验，未考虑其他影响<br>代码实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConnectionPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread() &#123;<span class="comment">//传统方式100个线程每个都创建新的连接</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">                    Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line"><span class="comment">//try-with-resource</span></span><br><span class="line">                            <span class="keyword">try</span> (Connection c = DriverManager</span><br><span class="line">                                    .getConnection(<span class="string">"jdbc:mysql://58.198.176.191:3306/yjsy_copy?characterEncoding=UTF-8"</span>,</span><br><span class="line">                                            <span class="string">"yjsy_nginx"</span>, <span class="string">"root"</span>);</span><br><span class="line">                                 Statement st = c.createStatement();</span><br><span class="line">                            ) &#123;</span><br><span class="line">                                    String sql = <span class="string">"insert into hero values(null,"</span> + <span class="string">"'提莫'"</span> + <span class="string">","</span> + <span class="number">313.0f</span> + <span class="string">","</span> + <span class="number">50</span> + <span class="string">")"</span>;</span><br><span class="line">                                    st.execute(sql);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    t.start();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        t.join();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">"使用100个线程均重新连接数据库的传统方式"</span>);</span><br><span class="line">                System.out.println(<span class="string">"插入100条数据所需要的时间为:"</span> + (t2 - t1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread() &#123; <span class="comment">//使用数据库连接池创建100个对象</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">                ConnectionPool cp = <span class="keyword">new</span> ConnectionPool(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    Thread t = <span class="keyword">new</span> WorkingThread(cp);</span><br><span class="line">                    t.start();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        t.join();<span class="comment">// 主线程需要等待子线程执行完成之后再结束</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">"使用100个线程通过数据库连接池进行连接的方式"</span>);</span><br><span class="line">                System.out.println(<span class="string">"插入100条数据所需要的时间为:"</span> + (t2 - t1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkingThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    ConnectionPool cp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkingThread</span><span class="params">( ConnectionPool cp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cp = cp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection c = cp.getConnection();</span><br><span class="line">        <span class="keyword">try</span>(Statement st = c.createStatement();) &#123;</span><br><span class="line">            String sql = <span class="string">"insert into hero values(null,"</span> + <span class="string">"'提莫'"</span> + <span class="string">","</span> + <span class="number">313.0f</span> + <span class="string">","</span> + <span class="number">50</span> + <span class="string">")"</span>;</span><br><span class="line">            st.execute(sql);</span><br><span class="line">            <span class="comment">//System.out.println("一条数据通过数据库连接池方式被插入");</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        cp.returnConnection(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据库连接池类：ConnectionPool</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Connection&gt; cs = <span class="keyword">new</span> ArrayList&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里恰恰不能使用try-with-resource的方式，因为这些连接都需要是"活"的，不要被自动关闭了</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Connection c = DriverManager</span><br><span class="line">                        .getConnection(<span class="string">"jdbc:mysql://58.198.176.191:3306/yjsy_copy?characterEncoding=UTF-8"</span>, <span class="string">"yjsy_nginx"</span>, <span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">                cs.add(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cs.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Connection c = cs.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">returnConnection</span><span class="params">(Connection c)</span> </span>&#123;</span><br><span class="line">        cs.add(c);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong> ：<img src="/images/202006/connectionpoolresult.png" alt="connectionpoolvs"><br>比较可以看出使用数据库连接池会比传统的连接数据库的方式在该场景下会快50%以上，可以重复使用数据库的连接资源，比传统每次连接需要创建关闭，要节约很多的时间</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;向数据库中插入100条数据，比较传统方式和数据库连接池方式的性能差异&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="数据库连接" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="Java Web" scheme="http://yoursite.com/tags/Java-Web/"/>
    
  </entry>
  
  <entry>
    <title>leetcode101. 对称二叉树</title>
    <link href="http://yoursite.com/2020/05/31/leetcode101/"/>
    <id>http://yoursite.com/2020/05/31/leetcode101/</id>
    <published>2020-05-31T12:15:04.000Z</published>
    <updated>2020-05-31T12:22:19.765Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，检查它是否是镜像对称的。<br><a id="more"></a><br>例如，二叉树 [1,2,2,3,4,4,3] 是对称的,[1,2,2,null,3,null,3] 则不是镜像对称的,<br><strong>分析</strong>：要判断二叉树是否镜像，首先要判断根结点的左右子树值是否相等，然后判断左子树左节点和右子树右节点的值，和左子树的右节点和右子树左节点的值得是否相等。可以分解为两个树的是否镜像<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mirror(root,root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">mirror</span><span class="params">(TreeNode n1,TreeNode n2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n1==<span class="keyword">null</span>&amp;&amp; n2==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(n1==<span class="keyword">null</span> || n2==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> n1.val==n2.val &amp;&amp; mirror(n1.left,n2.right) &amp;&amp;mirror(n1.right,n2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，检查它是否是镜像对称的。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Servlet开发（三）</title>
    <link href="http://yoursite.com/2020/05/31/servlet3/"/>
    <id>http://yoursite.com/2020/05/31/servlet3/</id>
    <published>2020-05-31T06:03:47.000Z</published>
    <updated>2020-05-31T12:36:34.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Servlet跳转"><a href="#Servlet跳转" class="headerlink" title="Servlet跳转"></a>Servlet跳转</h2><ul><li>服务端跳转</li><li>客户端跳转</li></ul><a id="more"></a><p>设计登陆成功和失败的两个页面success.html、fail.html。</p><h3 id="服务端跳转"><a href="#服务端跳转" class="headerlink" title="服务端跳转"></a>服务端跳转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"success.html"</span>).forward(request, response);</span><br></pre></td></tr></table></figure><h3 id="客户端跳转"><a href="#客户端跳转" class="headerlink" title="客户端跳转"></a>客户端跳转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"fail.html"</span>);</span><br></pre></td></tr></table></figure><p>修改后的LoginServlet类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">        String password = request.getParameter(<span class="string">"password"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"admin"</span>.equals(name) &amp;&amp; <span class="string">"123"</span>.equals(password))</span><br><span class="line">request.getRequestDispatcher(<span class="string">"success.html"</span>).forward(request, response);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        response.sendRedirect(<span class="string">"fail.html"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：服务端跳转地址会由 <a href="http://127.0.0.1/login.html" target="_blank" rel="noopener">http://127.0.0.1/login.html</a> 改变为 <a href="http://127.0.0.1/login" target="_blank" rel="noopener">http://127.0.0.1/login</a> ，而客户端跳转会改变地址<a href="http://127.0.0.1/fail.html" target="_blank" rel="noopener">http://127.0.0.1/fail.html</a> ，这是因为服务端跳转还是在web.xml配置的/login映射的LoginServlet中，是在服务器内部访问success.html，而客户端跳转是发送跳转信息给浏览器，使得浏览器访问新的页面。</p><h2 id="配置Servlet自启动"><a href="#配置Servlet自启动" class="headerlink" title="配置Servlet自启动"></a>配置Servlet自启动</h2><p>在项目的web.xml中，配置HelloServlet的地方，配置如下属性：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>10<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>取值为1-99，表示启动顺序，这样启动tomcat时就会启动该Servlet，可以复写init(ServletConfig)方法验证<br>而windows下开机自启动tomcat，需要配置电脑环境系统变量，新建变量名CATALINA_HOME，值为tomcat位置，我的是F:\eclipse\tomcat，然后在path下添加%CATALINA_HOME%\bin\;，最后进入到tomcat\bin下运行service.bat install，安装tomcat服务，然后就可以在计算机服务中设置自启动了</p><h2 id="Servlet-request和response常见方法"><a href="#Servlet-request和response常见方法" class="headerlink" title="Servlet request和response常见方法"></a>Servlet request和response常见方法</h2><p><strong>request常见方法</strong>：<br>request.getParameter(): 是常见的方法，用于获取单值的参数<br>request的setAttribute()和getAttribute()可以用来在进行服务端跳转的时候，在不同的Servlet之间进行数据共享<br><strong>response常见方法</strong>：<br>前文用到response.getWriter()来返回给浏览器html的内容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter pw= response.getWriter();</span><br></pre></td></tr></table></figure></p><p>setContentType可以设置响应格式，text/html为html格式，而其他格式会被识别为文件下载<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">"text/html"</span>);</span><br></pre></td></tr></table></figure></p><h2 id="Servlet上传文件"><a href="#Servlet上传文件" class="headerlink" title="Servlet上传文件"></a>Servlet上传文件</h2><h3 id="创建upload-html文件"><a href="#创建upload-html文件" class="headerlink" title="创建upload.html文件"></a>创建upload.html文件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"uploadPhoto"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  英雄名称:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"heroName"</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  上传头像 : <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"filepath"</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&lt;form&gt;的method必须是post的，get不能上传文件, 还需要加上enctype=”multipart/form-data” 表示提交的数据是二进制文件.</p><h3 id="创建UploadPhotoServlet类"><a href="#创建UploadPhotoServlet类" class="headerlink" title="创建UploadPhotoServlet类"></a>创建UploadPhotoServlet类</h3><p>在UploadPhotoServlet中进行上传的功能开发。<br>注：需要用到两个第三方的jar包，<a href="http://archive.apache.org/dist/commons/io/" target="_blank" rel="noopener">commons-io-2.5.jar</a> 和<a href="http://archive.apache.org/dist/commons/fileupload/" target="_blank" rel="noopener">commons-fileupload-1.3.3.jar</a>,存放在WEB-INF/lib下，并导入到项目中：右键 project-&gt;properties-&gt;java build path-&gt;libaries-&gt;add external jars</p><p>UploadPhotoServlet类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.FileItem;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.FileUploadException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.disk.DiskFileItemFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.servlet.ServletFileUpload;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadPhotoServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        String filename = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">            ServletFileUpload upload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">            <span class="comment">// 设置上传文件的大小限制为1M</span></span><br><span class="line">            factory.setSizeThreshold(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">             </span><br><span class="line">            List items = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                items = upload.parseRequest(request);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileUploadException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            Iterator iter = items.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                FileItem item = (FileItem) iter.next();</span><br><span class="line">                <span class="comment">//用来处理是常规字段还是提交的文件</span></span><br><span class="line">                <span class="keyword">if</span> (!item.isFormField()) &#123;</span><br><span class="line">  </span><br><span class="line">                    <span class="comment">// 根据时间戳创建头像文件</span></span><br><span class="line">                    filename = System.currentTimeMillis() + <span class="string">".jpg"</span>;</span><br><span class="line">                     </span><br><span class="line">                    <span class="comment">//通过getRealPath获取上传文件夹，如果项目在F:\Java\workspace\j2ee\web,那么就会自动获取到 F:\Java\workspace\j2ee\web\uploaded</span></span><br><span class="line">                    String photoFolder =request.getServletContext().getRealPath(<span class="string">"uploaded"</span>);</span><br><span class="line">                     </span><br><span class="line">                    File f = <span class="keyword">new</span> File(photoFolder, filename);</span><br><span class="line">                    f.getParentFile().mkdirs();</span><br><span class="line">  </span><br><span class="line">                    <span class="comment">// 通过item.getInputStream()获取浏览器上传的文件的输入流</span></span><br><span class="line">                    InputStream is = item.getInputStream();</span><br><span class="line">  </span><br><span class="line">                    <span class="comment">// 复制文件</span></span><br><span class="line">                    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">                    <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">                    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (-<span class="number">1</span> != (length = is.read(b))) &#123;</span><br><span class="line">                        fos.write(b, <span class="number">0</span>, length);</span><br><span class="line">                    &#125;</span><br><span class="line">                    fos.close();</span><br><span class="line">  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(item.getFieldName());</span><br><span class="line">                    String value = item.getString();</span><br><span class="line">                    value = <span class="keyword">new</span> String(value.getBytes(<span class="string">"ISO-8859-1"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line">                    System.out.println(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            String html = <span class="string">"&lt;img width='200' height='150' src='uploaded/%s' /&gt;"</span>;</span><br><span class="line">            response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">            PrintWriter pw= response.getWriter();</span><br><span class="line">             </span><br><span class="line">            pw.format(html, filename);</span><br><span class="line">             </span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在web.xml中配置映射:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>UploadPhotoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>UploadPhotoServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>UploadPhotoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/uploadPhoto<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Servlet跳转&quot;&gt;&lt;a href=&quot;#Servlet跳转&quot; class=&quot;headerlink&quot; title=&quot;Servlet跳转&quot;&gt;&lt;/a&gt;Servlet跳转&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;服务端跳转&lt;/li&gt;
&lt;li&gt;客户端跳转&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Servlet" scheme="http://yoursite.com/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>Servlet开发（二）</title>
    <link href="http://yoursite.com/2020/05/31/servlet2/"/>
    <id>http://yoursite.com/2020/05/31/servlet2/</id>
    <published>2020-05-31T03:46:24.000Z</published>
    <updated>2020-05-31T12:36:47.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HttpServlet类"><a href="#HttpServlet类" class="headerlink" title="HttpServlet类"></a>HttpServlet类</h2><p>HttpServlet继承抽象类GenericServlet，GenericServlet类实现了Servlet, ServletConfig接口。</p><a id="more"></a>  <p>HttpServlet类：<br><img src="/images/202005/HttpServlet.png" alt="HttpServlet类"><br>GenericServlet类：<br><img src="/images/202005/GenericServlet.png" alt="GenericServlet类"></p><p>Servlet 需要提供对应的doGet()与doPost()方法<br>在执行doGet()或者doPost()之前，都会先执行service()，根据请求提交方式来判断使用调用doGet()还是doPost()，因此也可以复写service()方法，提供相应服务。</p><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p>一个Servlet的生命周期由实例化，初始化，提供服务，销毁，被回收几个步骤组成<br><strong>实例化</strong>：<br>当用户通过浏览器输入一个路径，这个路径对应的servlet被调用的时候，该Servlet就会被实例化<br>为LoginServlet显式提供一个构造方法 LoginServlet()<br>而无论访问了多少次LoginServlet，LoginServlet构造方法只会执行一次，所以Servlet是单实例的<br><strong>初始化</strong>：<br>LoginServlet 继承了HttpServlet，同时也继承了init(ServletConfig) 方法<br>init 方法是一个实例方法，所以会在构造方法执行后执行。<br>无论访问了多少次LoginSerlvet<br>init初始化 只会执行一次<br><strong>提供服务</strong>：<br>接下来就是执行service()方法，然后通过浏览器传递过来的信息进行判断，是调用doGet()还是doPost()方法<br>service()中也可以编写业务代码，比如判断用户输入的账号和密码是否正确<br><strong>销毁</strong>：<br>销毁为destroy()<br>在如下几种情况下，会调用destroy()<br>1、 该Servlet所在的web应用重新启动，在server.xml中配置该web应用的时候用到了<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/"</span> <span class="attr">docBase</span>=<span class="string">"e:\\project\\j2ee\\web"</span> <span class="attr">debug</span>=<span class="string">"0"</span> <span class="attr">reloadable</span>=<span class="string">"false"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果把 reloadable=”false” 改为reloadable=”true” 就表示有任何类发生的更新，web应用会自动重启<br>当web应用自动重启的时候，destroy()方法就会被调用<br>2、关闭tomcat的时候 destroy()方法会被调用<br><strong>回收</strong>：<br>当该Servlet被销毁后，就满足垃圾回收的条件了。当下一次GC时，就有可能被回收。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HttpServlet类&quot;&gt;&lt;a href=&quot;#HttpServlet类&quot; class=&quot;headerlink&quot; title=&quot;HttpServlet类&quot;&gt;&lt;/a&gt;HttpServlet类&lt;/h2&gt;&lt;p&gt;HttpServlet继承抽象类GenericServlet，GenericServlet类实现了Servlet, ServletConfig接口。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Servlet" scheme="http://yoursite.com/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>Servlet开发（一）</title>
    <link href="http://yoursite.com/2020/05/31/servlet1/"/>
    <id>http://yoursite.com/2020/05/31/servlet1/</id>
    <published>2020-05-31T03:44:46.000Z</published>
    <updated>2020-06-15T08:58:03.065Z</updated>
    
    <content type="html"><![CDATA[<p>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。<br>使用Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。<br><a id="more"></a><br>开发Servlet分三步：</p><ul><li>创建Web应用项目</li><li>编写servlet代码</li><li>部署到tomcat中</li></ul><h2 id="1、搭建tomcat"><a href="#1、搭建tomcat" class="headerlink" title="1、搭建tomcat"></a>1、搭建tomcat</h2><p>Tomcat是常见的免费的web服务器. 下载安装使用即可，成功后进入tomcat目录，/tomcat/bin/startup.bat，其中启动是startup.bat，关闭时shutdown.bat，linux环境下为同名的.sh文件，将一个html文件，如login.html，放置于/tomcat/webapps/ROOT文件下，启动tomcat，既可以成功用浏览器访问localhost:8080/login.html。<br>这样就成功搭建了一个简单web服务器啦~<br>你可以对此做简单的修改，比如修改端口<br>tomcat的相关配置信息在/tomcat/conf/server.xml中。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>找到如上的代码，将8080修改为80即可，由于80是web服务器默认的端口号，所以你平时访问网站，没有看到端口号，就是因为在80中，或者是访问80，反向代理到其他位置。</p><h2 id="2、创建Web应用项目"><a href="#2、创建Web应用项目" class="headerlink" title="2、创建Web应用项目"></a>2、创建Web应用项目</h2><p>创建简单的java project项目即可。<br>下面直接贴项目文件和代码<br><img src="/images/202005/myservlet.png" alt="Myservlet"><br>其中j2ee为项目名，src下分别建了HelloServlet类和LoginServlet类，都继承HttpServlet类，分别实现doGet()和doPost()来处理请求和响应，servlet-api.jar为开发Servlet相关的包，在\tomcat\lib\servlet-api.jar。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">"&lt;h1&gt;Hello Servlet!&lt;/h1&gt;"</span>);</span><br><span class="line">            response.getWriter().println(<span class="keyword">new</span> Date().toLocaleString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//设置字符编码,获取中文参数</span></span><br><span class="line">    request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">    </span><br><span class="line">        String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">        String password = request.getParameter(<span class="string">"password"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//或者解码再编码得到中文,建议使用上者</span></span><br><span class="line">        <span class="comment">// byte[] bytes = name.getBytes("ISO-8859-1");</span></span><br><span class="line">        <span class="comment">// name = new String(bytes, "UTF-8");</span></span><br><span class="line">        System.out.println(<span class="string">"name:"</span> + name);</span><br><span class="line">        </span><br><span class="line">        String html = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"admin"</span>.equals(name) &amp;&amp; <span class="string">"123"</span>.equals(password))</span><br><span class="line">            html = <span class="string">"&lt;div style='color:green'&gt;success&lt;/div&gt;"</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            html = <span class="string">"&lt;div style='color:red'&gt;fail&lt;/div&gt;"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回中文,对response设置</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html; charset=UTF-8"</span>);</span><br><span class="line">        PrintWriter pw = response.getWriter();</span><br><span class="line">        pw.println(html);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>web.xml提供路径与servlet的映射关系，如把/hello这个路径，映射到 HelloServlet这个类上<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>login.html为前端的登陆页。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>登录页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"login"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">账号: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">密码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>还要在WEB-INF下创建classes目录，用于把项目的class文件输出到该文件下，使得tomcat可以在WEB-INF下被找到.<br><strong>步骤</strong>：项目右键-&gt;properties-&gt;Java Build Path-&gt;Source-&gt;右下角的Brower-&gt; 指定位置是j2ee/web/WEB-INF/classes。</p><p>最后配置tomcat的server.xml 中的&lt;context&gt;&gt;<br>在&lt;Host name=”localhost” …&gt;下面加一句:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/"</span> <span class="attr">docBase</span>=<span class="string">"你的项目文件名\\j2ee\\web"</span> <span class="attr">debug</span>=<span class="string">"0"</span> <span class="attr">reloadable</span>=<span class="string">"false"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样就可以通过 <a href="http://127.0.0.1/hello" target="_blank" rel="noopener">http://127.0.0.1/hello</a> 访问到hello.html了,并实现简单的登陆功能<br><img src="/images/202005/loginhtml.png" alt="LoginHtml"><br>由于上面已将项目部署的path修改到了新的目录，所以tomcat下的ROOT需要删除，防止冲突，不过也可以将项目打包至ROOT目录下，这里没用这个</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>1、tomcat运行，启动/tomcat/bin/startup.bat，但有错见图1，需在/tomcat/bin/setclasspath.bat配置JAVA_HOME和JRE_HOME，切记：赋值中间不能有空格，配置见图2<br><img src="/images/202005/tomcaterror1.png" alt="启动Tomcat报错"><br><img src="/images/202005/tomcatset.png" alt="Tomcat配置"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。&lt;br&gt;使用Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Servlet" scheme="http://yoursite.com/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 84、柱状图中最大的矩形</title>
    <link href="http://yoursite.com/2020/05/30/leetcode84/"/>
    <id>http://yoursite.com/2020/05/30/leetcode84/</id>
    <published>2020-05-30T02:39:52.000Z</published>
    <updated>2020-05-30T05:56:58.935Z</updated>
    
    <content type="html"><![CDATA[<p><strong>描述</strong>：给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。<br><a id="more"></a><br><img src="/images/202005/leetcode84.png" alt="LeetCode84"><br>图中最大矩形面积，为高度5和6两根柱子所构成的，其面积为 10 个单位。</p><p>题解：<br>1、用暴力法，取每根柱子向两边延展所能得到的最大面积，最后比较各面积大小，时间复杂度为O(n^2),空间复杂度O(1).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line"><span class="comment">//计算每个柱子所能勾勒的最大面积</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">            res = Math.max(res, countPerArea(heights, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPerArea</span><span class="params">(<span class="keyword">int</span>[] heights, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = index, right = index;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; heights[left] &gt;= heights[index]) &#123;</span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; heights.length &amp;&amp; heights[right] &gt;= heights[index]) &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (right - left - <span class="number">1</span>) * heights[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>2、看的题解，使用单调栈，以高度单调递增的柱子入栈，当遇到更低的柱子，则出栈，向前维护高柱子所得到的面积。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len=heights.length;</span><br><span class="line"><span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] newHeights=<span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">2</span>];</span><br><span class="line"><span class="comment">//为了避免剩余栈中元素，前后加0高度的哨兵</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">newHeights[i]=heights[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">len+=<span class="number">2</span>;</span><br><span class="line">heights=newHeights;</span><br><span class="line">Deque&lt;Integer&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">stack.addLast(<span class="number">0</span>);</span><br><span class="line">stack.offerLast(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">while</span> (heights[stack.peekLast()]&gt;heights[i])&#123;</span><br><span class="line"><span class="comment">//[0,2,1,5,6,2,3,0]为例，当i为5时，此时为2，栈顶6大于2</span></span><br><span class="line"><span class="comment">//那么出栈6，此时高度为6，宽度为1;</span></span><br><span class="line"><span class="comment">//后续栈顶5依旧大于2，出栈处理高度5的柱子</span></span><br><span class="line"><span class="keyword">int</span> height =heights[stack.pollLast()];</span><br><span class="line"><span class="keyword">int</span> width=i-stack.peekLast()-<span class="number">1</span>;</span><br><span class="line">res=Math.max(res,width*height);</span><br><span class="line">&#125;</span><br><span class="line">stack.offerLast(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。&lt;br&gt;求在该柱状图中，能够勾勒出来的矩形的最大面积。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>vivo 2020届校招在线编程笔试B卷</title>
    <link href="http://yoursite.com/2020/05/29/vivo2020B/"/>
    <id>http://yoursite.com/2020/05/29/vivo2020B/</id>
    <published>2020-05-29T02:48:49.000Z</published>
    <updated>2020-05-29T03:04:33.016Z</updated>
    
    <content type="html"><![CDATA[<p>牛客vivo2020校招编程题解<br><a id="more"></a></p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>今年7月份vivo迎来了新入职的大学生，现在需要为每个新同事分配一个工号。人力资源部同事小v设计了一个方法为每个人进行排序并分配最终的工号，具体规则是：</p><blockquote><p>将N（N&lt;10000）个人排成一排，从第1个人开始报数；如果报数是M的倍数就出列，报到队尾后则回到队头继续报，直到所有人都出列；</p></blockquote><p>最后按照出列顺序为每个人依次分配工号。请你使用自己擅长的编程语言帮助小v实现此方法。<br>解法：使用循环单链表，依次出队<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] input)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO Write your code here</span></span><br><span class="line"><span class="keyword">int</span> n=input[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> m=input[<span class="number">1</span>];</span><br><span class="line">ListNode people=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">ListNode p = people;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ListNode node=<span class="keyword">new</span> ListNode(i);</span><br><span class="line">p.next=node;</span><br><span class="line">p=p.next;</span><br><span class="line">&#125;</span><br><span class="line">p.next=people;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> out=n;</span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">p=people;</span><br><span class="line"><span class="keyword">while</span>(out&gt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">p=p.next;</span><br><span class="line">&#125;</span><br><span class="line">sb.append(p.val);</span><br><span class="line">sb.append(<span class="string">" "</span>);</span><br><span class="line">p.val=p.next.val;</span><br><span class="line">p.next=p.next.next;</span><br><span class="line">out--;</span><br><span class="line">&#125;</span><br><span class="line">sb.append(p.val);</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>小v在公司负责游戏运营，今天收到一款申请新上架的游戏“跳一跳”，为了确保提供给广大玩家朋友们的游戏都是高品质的，按照运营流程小v必须对新游戏进行全方位了解体验和评估。这款游戏的规则如下：</p><blockquote><p>有n个盒子排成了一行，每个盒子上面有一个数字a[i]，表示在该盒子上的人最多能向右移动a[i]个盒子（比如当前所在盒子上的数字是3，则表示可以一次向右前进1个盒子，2个盒子或者3个盒子）。</p></blockquote><p>现在小v从左边第一个盒子上开始体验游戏，请问最少需要移动几次能到最后一个盒子上？<br>分析：最远跳跃，依次保留每次跳跃中的可以跳跃到下一次的最远距离<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] input)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Write your code here</span></span><br><span class="line"><span class="keyword">if</span>(input == <span class="keyword">null</span>||input.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len=input.length;</span><br><span class="line"><span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxReach=input[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(maxReach &lt; i) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//如果不能到达最后，则返回-1</span></span><br><span class="line"><span class="comment">//记录各节点所能到达的最远距离</span></span><br><span class="line">maxReach=Math.max(maxReach,i+input[i]); </span><br><span class="line"><span class="keyword">if</span>(maxReach &gt;= len-<span class="number">1</span>) <span class="keyword">return</span> (step+<span class="number">1</span>);<span class="comment">//超出则直接返回</span></span><br><span class="line"><span class="keyword">if</span>(i==end)&#123;</span><br><span class="line">end = maxReach;</span><br><span class="line">step++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>小v最近在玩一款挖矿的游戏，该游戏介绍如下：</p><blockquote><p>1、每次可以挖到多个矿石，每个矿石的重量都不一样，挖矿结束后需要通过一款平衡矿车运送下山；<br>2、平衡矿车有左右2个车厢，中间只有1个车轮沿着导轨滑到山下，且矿车只有在2个车厢重量完全相等且矿石数量相差不超过1个的情况下才能成功运送矿石，否则在转弯时可能出现侧翻。</p></blockquote><p>假设小v挖到了n（n&lt;100）个矿石，每个矿石重量不超过100，为了确保一次性将n个矿石都运送出去，一旦矿车的车厢重量不一样就需要购买配重砝码。请问小v每次最少需要购买多少重量的砝码呢? （假设车厢足够放下这些矿石和砝码，砝码重量任选）<br>分析：开始用得贪心，不能ac,,看评论用的动态规划，不是很理解，贴上代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] input)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Write your code here</span></span><br><span class="line"><span class="keyword">int</span> n = input.length; <span class="comment">//n为石块数</span></span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>; <span class="comment">//s记录总重量，题解要尽可能满足两边平均</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">s += input[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> S = s &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> N = (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[S + <span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= S; ++i) dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span>[][] tmp=dp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = input[i]; j &lt;= S; ++j) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; ++k) &#123;</span><br><span class="line">tmp[j][k] = Math.max(tmp[j][k], dp[j - input[i]][k - <span class="number">1</span>] + input[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">dp=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((n &amp; <span class="number">1</span>)==<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> s - <span class="number">2</span> * Math.max(dp[S][N], dp[S][N - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s - <span class="number">2</span> * dp[S][N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;牛客vivo2020校招编程题解&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="OJ" scheme="http://yoursite.com/tags/OJ/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
